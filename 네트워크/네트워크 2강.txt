1)계층적 모듈구조.
	모듈의 장점은 시스템구조가 단순해져 각 계층을 이해하기가 쉽다(독립성). 또한 유지보수가 간편해짐. ( 상위계층은 서비스 요청 하위계층은 서비스 제공 )
	프로토콜은 시스템이 데이터를 교환할 떄는 임의의 통신 규칙.(동일계층으로 ~)

2)프로토콜 설계
	1> 주소표현 - 호스트를 유일하게 구분짓는 용도
	시스템을 구분하여 지칭하기 위해 이름을 부여하는 것 이것이 주소 체계이다.(확장성 고려)
	브로딩캐스팅 : 네트워크에 연결된 모든 호스트에 데이터를 전송할 수 있는 표기방식
	멀티캐스팅 : 특정사용자를 그룹으로 묶어 지칭하는 표기방식.

	2>오류 제어 - 데이터가 변형/분실 시 복구용도
	데이터변형오류, 데이터분실오류 -> 전송 오류 문제를 해결하는 오류제어기능
	그럼 오류가 왜 발생하는가?
	1차적인 원인은 물리 계층의 전송 매체에 의한 물리적인 오류 --> 데이터링크계층이 해결 !
	분실했을 땐 인지하기가 어렵다.. 대충 시간을 서로 맞추고 그 시간내에 아무런 반응이 없으면 재전송** 을한다.

	3>흐름 제어 - 송신자가 데이터를 너무 빨리 보내서 수신자가 처리하지 못한 문제를 해결하기 위한 목적.
	수신 호스트의 제어를 통해 전송허가를 보내도록 하자.

	4>데이터 전달 방식
	단방향 , 전이중(양쪽에서 ㅎㅎ), 반이중(특정시점에선 한쪽으로만 제어를 걸어두는거죠)

3) 서비스 프리미티브
	프로토콜은 계층구조, 계층 구조 프로토콜에서 하위 계층이 상위 계층에 제공하는 서비스의 종류에는 연결형/비연결형이  있고 프리미티브 형태로 구현된다
	그래서 프리미티브는 하위 계층을 사용하는 방법을 정형화 한것.
	그럼 연결형 프리미티브(CONNECT, DATA, DISCONNECT) -> 서비스 프리미티브를 알아보자
	Request : 클라이언트에서 발생하며, 서버가 프리미티브의 기능을 수행하도록 하위 프로토콜에 요청할 때 사용 
	Indication : 클라이언트 하위프로토콜이 Request 수신한 서버의 하위계층은 Indication을 사용해서 프리미티브 요청이 발생했음을 알린다.
	Response : 위 과정을 다 거쳐서 프리미티브를 받은 서버는 클라이언트에게 응답한다.
	Confirm : 서버에서 보낸 응답은 클라이언트에게 회신된다.

4) OSI 참조모델
	헤더정보는 각 계층에 내려갈 때마다 추가된다. 올라 갈 땐 제거. 반복~
	송신호스트 -> 중개 호스트(라우팅) -> 수신 호스트 ...  라우터는 헤더 정보의 값을 해석하여 변환하는 작업은 중요기능. (네트워크 계층은 라우팅알고리즘을 통해 빠른 루트를 찾는다)
	전송계층 중요 : 종단연결을 제공하며, 프로세스와 프로세스 사이의 연결을 설정하여 데이터를 주고 받을 수 있게 함.

	물리계층 - 전송매체의 전송매체의 물리적 인터페이스 기술
	데이터링크계층- 데이터의 물리적 전송 오류 해결.
	네트워크 계층 - 혼잡제어기능!
	
5) TCP/IP 모델
	많은 프로세스 <-> [TCP IP 드라이브 루틴] <-> 랜카드  
	ARP : 상대방 호스트 IP를 이용하여 MAC 주소 파악
	RARP : MAC 주소를 이용하여 IP파악 ( 하드디스크가 없는 시스템..)
	ICMP : IP 오류발생시 반드시 송신자에게 회산하여 복구 작업을 하는데 이역할을 함. 별도의 오류메시지를 위한 별도의 헤더구조를 가짐.  여기 세 개 다 프로토콜임